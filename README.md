# VK-LabelPropogation
### Описание алгоритма:
Допустим, что большинство соседей какой-либо вершины принадлежат одному сообществу. Тогда, с высокой вероятностью, ему также будет принадлежать выбранная вершина. На этом предположении и строится алгоритм Label propagation: каждая вершина в графе определяется в то сообщество, которому принадлежит большинство его соседей. Если же таких сообществ несколько, то выбирается случайно одно из них.
В начальный момент времени всем вершинам ставится в соответствие отдельное сообщество. Затем происходят перераспределения сообществ. Из-за случайности важно на каждой итерации изменять порядок обхода вершин. Алгоритм заканчивает работу, когда нечего изменять: все вершины относятся к тем сообществам, что и большинство их соседей.
### Реализация алгоритма Label Propogation с использованием многопоточности для ускорения процесса *поиска communities* в неориентированном графе. 
На вход подается список рёбер, запускается алгоритм, на каждой итерации в промежуточные выходные файлы с префиксом `interim_calculations` записываются текущие метки для всех рёбер.
По окончанию работы алгоритма в выходном файле `links.txt` для каждой вершины графа содержится `communityId`, присвоенный во время работы алгоритма. После этого происходит переприсваивание меток, и в выходной файл `sorted_links.txt` записывается информация по communities в формате: 
`communityId: [список вершин, входящих в текущую community]`

Протестировано на данном датасете, который находится по [ссылке](https://snap.stanford.edu/data/egonets-Facebook.html).
Результаты получились аппроксимирующие - протестировав программу на всех входных файлах с расширением `.edges` из данного датасета, содержащими список входных рёбер, получил коррелирующие списки в выходных файлах датасета `.circles` и своих output-файлах `sorted_links.txt`
#### Пример полученных данных:

`sorted_links.txt`:

![logo](https://github.com/sahipchic/VK-LabelPropogation/blob/master/screen1.png "Logo")


`0.circles`:

![logo](https://github.com/sahipchic/VK-LabelPropogation/blob/master/screen2.png "Logo")

Количество полученных communities постоянно коррелирует из-за присутствия в алгоритме случайного выбора вершин в зависимости от полученных данных на предыдущих итерациях.


Реализованный здесь алгоритм имеет практически линейное время, выдаёт хорошие результаты и вполне может быть использован для поиска communities в сетях с большим набором данных.
